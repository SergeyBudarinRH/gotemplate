# Общее описание задачи по микросервису v3

## Intro/Введение

В процессе обучения нам предстоит разработать систему из 4ех микросервисов, которая будет собирать состояние других сервисов и систем, сохранять собранное состояние в базу данных и предоставлять WEB API для доступа к сохраненным данным (сильно упрощенный аналог [Prometheus-a](https://prometheus.io/docs/introduction/overview/))

Исходный код для всей системы и заданий на закрепление материала будет храниться в одном монорепозитории. Подробнее о монорепозитории вы можете посмотреть или почитать в докладе с конференции GolangLive 2020 [Habr](https://habr.com/ru/company/oleg-bunin/blog/531632/)/[Youtube](https://www.youtube.com/watch?v=vnQeTsY-mKs&list=PL4jag8ijtDPyYMb9_JDZ2UYZko2sGBcOj&index=7)

Напишем утилиту интеграционного тестирования и проверим с ее помощью наш сервис.

## Состав системы в конечном виде, как она будет деплоиться в Kubernetes-кластер

1. Контейнер с базой данных (`PG`) и накатанными на нее миграциями (в бд созданы все необходимые таблицы, индексы, ограничения и т.п.)
2. Контейнер с сервисом ([gometr](https://gitlab.slurm.io/GoForOps/gometr)), сервис уже разработан и находится в папке Service. Предоставляет 2 http endpoint-a для GET запросов:
   1. `/metrics` – метрики в формате Prometheus
   2. `/health` – состояние здоровья, важен http статус ответа 200 ОК
3.  Контейнер с сервисом (`Api Service`), извлекающим данные из нашей базы данных и предоставляющим 2 http endpoint-a для GET запросов:
    1.  `/api/v1/metrics` – показывает метрики, сохраненные в базе данных
    2.  `/api/v1/checks` – показывает проверки состояния
4.  Контейнер с сервисом (`Our service`), который будет опрашивать настроенные для него цели по сбору метрик и проверки состояния и сохранять результаты в нашу базу данных

## Структурная схема нашей системы

![service-map](assets/Сервис-Общая%20схема_mapping.png)

1. [GoMetr](https://gitlab.slurm.io/GoForOps/gometr) - сервис, предоставляющий свой статус и метрики. Один из вариантов таргетов для опроса нашей системой.
2. `GoogleMetr` - произвольный вэб сервис, обрабатывающий GET запросы. Им может быть и сам GoMetr. Еще один из вариантов таргетов для опроса нашей системой.
3. `Our service` - разработанное нами приложение, которое будет опрашивать настроенные для него цели (например GoMetr, GoogleMetr...) по сбору метрик и проверки состояния и сохранять результаты в нашу базу данных.
4. `Checker` - компонент нашего сервиса, по настроенному расписанию производит сбор метрик и проверку состояний, сохраняя результаты в репозиторий.
5. `[]Cheсkable` - часть `Checker`-а, слайс интерфейсов Cheсkable, описывающих методы для сбора метрик и состояний.
6. `GoMetrClient` - реализация интерфейса Cheсkable, обрабатывает метрики в формате Prometheus.
7. `GoogleClient` - реализация интерфейса Cheсkable, обрабатывает результаты простых GET запросов, формируя метрики в нужном формате.
8. `Repository Write Interface` - компонент `Checker`-а, интерфейс, описывающий методы записи данных в абстрактное хранилище
9. `PG` - PostgreSQL имплементация хранилища для записи и чтения
10. `Api Service` - WEB API предоставления доступа к данным в нашей базе данных
11. `API` - компонент `Api Service` представляющий собой набор http хендлеров, обрабатывающих запросы
12. `Manager` - компонент `Api Service` реализует `API`
13. `Repository Read Interface` - компонент `Manager`-а, интерфейс, описывающий методы чтения данных из абстрактного хранилища
14. Произвольный API клиент запрашивающий исторические данные метрик

## Этапы разработки

### Инициализация

**Цель**: Навык инициализации проекта  
**Что делаем**: Просто создаем директорию, в которой будет располагаться наш проект, переносим себе код [GoMetr](https://gitlab.slurm.io/GoForOps/gometr)  
**Артефакты**: Файлы в корне папки Service: main.go файл с константами и структурой

![service-7](assets/Сервис%20шаг%20-7.png)

### Формирование скелета системы

**Цель**: Навык инициализации проекта  
**Что делаем**: Добавляем базовые элементы системы в виде структур, поведение в виде интерфейсов, реализация с методами-заглушками (эмитация реальной работы). Размещаем их в плоском списке файлов  
**Артефакты**: Файлы в корне папки Service: checker.go, gometr.go, main.go

описание интерфейса Cheсkable и его реализация с заглушками
![service-6](assets/Сервис%20шаг%20-6.png)

добавляем в Checker слайс интерфейсов Cheсkable и синхронный вызов методов у экземпляров Cheсkable
![service-5](assets/Сервис%20шаг%20-5.png)

### Многопоточность в системе

**Цель**: Навык работы с конкурентностью в Go  
**Что делаем**: Рефакторим методы структур, реализуя новые требования к методам: таймауты, параллельная работа, периодичность запуска, управляемость. Реализуем методы сбора метрик в prometheus формате и просто метрики http GET запроса  
**Артефакты**: Файлы в одной папке: checker.go, gometr.go, main.go, googlemetr.go

![service-4](assets/Сервис%20шаг%20-4.png)

### Декомпозиция на пакеты, БД, WEB API

**Цель**: Навык разбиения системы на компоненты и размещение их в отдельных пакетах, мок интерфейса репозитрия, работа с БД PostgreSQL, реализация WEB API в монолитном приложении  
**Что делаем**: Рефакторим методы структур, добавляем работу с хранилищем данных. Разбиваем проект на пакеты и учимся организовывать код согласно рекомендациям в golang project layout. Учимся писать миграции для БД.  
**Артефакты**: структурированный проект согласно рекомендациям в golang project layout

Добавляем интерфейс репозитория с реализацией inmemory хранилища в виде map-ы
![service-3](assets/Сервис%20шаг%20-3.png)

Описываем репозиторий в виде интерфейса с методами записи и делаем реализацию для PosgreSQL
![service-2](assets/Сервис%20шаг%20-2.png)

Описываем дополнительный репозиторий в виде интерфейса с методами чтения и делаем реализацию для PosgreSQL. Добавляем WEB API на чтение данных в репозитории
![service-1](assets/Сервис%20шаг%20-1.png)

### Сборка docker image-a

**Цель**: Навык написания Dockerfile-ов  
**Что делаем**: Добавляем Dockerfile в проект  
**Артефакты**: Dockerfile в проекте

### Интеграционное тестирование самописной утилитой тестирования

**Цель**: Навык написания cli утилиты, работа с docker api, объединение своего приложения и утилиты тестирования  
**Что делаем**: Разрабатываем утилиту интеграционного тестирования и тестируем ей свой сервис и не только  
**Артефакты**: CLI утилита простого интеграционного тестирования

### Распил монолита + ручной deploy в Kubernetes кластер

**Цель**: Навык выделения функции из приложения в отдельное приложение и деплоя приложения в кластер Kubernetes-a.  
**Что делаем**: Отделяем WEB API от сервиса сборщика данных (метрик и доступности) укрепляя тем самым навык декомпозиции системы на пакеты. Выделение web api в отд приложение не должно приводить к переписыванию всего кода, а лишь к добавлению незначительного объема нового. Пишем манифесты для деплоя в кластер Kubernetes-a.  
**Артефакты**: монорепозиторий с файлами web api в отдельной папке cmd/restapi/main.go и сервиса коллектора данных cmd/checker/main.go, Kubernetes манифесты

![service](assets/Сервис-Общая%20схема.png)

### Управление жизненным циклом приложения при помощи Kubernetes operator-a

**Цель**: Навык написания Kubernetes operator-ов и их тестирование  
**Что делаем**: Пишем Kubernetes operator-a  
**Артефакты**: Проект с Kubernetes operator-ом
